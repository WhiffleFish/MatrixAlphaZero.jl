function mcts_exploitability(mdp_sol::MCTSSolver, model_dir::String, exploiter::Int)
    model_nums = eachindex(readdir(model_dir)) .- 1
    prog = Progress(length(model_nums))
    br_vals = map(model_nums) do i
        model_state = JLD2.load(joinpath(model_dir, "oracle"*AZ.iter2string(i)*".jld2"), "model_state")
        Flux.loadmodel!(oracle, model_state)
        pol = AlphaZeroPlanner(oracle, game, max_iter=0)
        brv = mcts_exploitability(mdp_sol, pol, exploiter)
        next!(prog)
        brv
    end
    finish!(prog)
    return br_vals
end

function mcts_exploitability(mdp_sol::MCTSSolver, pol::AlphaZeroPlanner, exploiter::Int)
    mdp = ExploitabilityMDP(game, pol, exploiter)
    mdp_pol = solve(mdp_sol, mdp)
    a, mdp_a_info = action_info(mdp_pol, s)
    root_idxs = Base.OneTo(length(actions(game)[exploiter]))
    return maximum(mdp_a_info.tree.q[root_idxs])
end

function planner_exploitability(oracle, mcts_sol, exploiter, sim; kwargs...)
    mdp = ExploitabilityMDP(game, AlphaZeroPlanner(game, oracle; max_iter=0), exploiter)
    mdp_pol = solve(mdp_sol, mdp)
    
    return map(1:n_iter) do
        simulate(sim, mdp, mdp_pol, s)
    end
end

struct JointPolicy{P<:Tuple} <: Policy
    pols::P
    JointPolicy(args...) = new{typeof(args)}(args)
    JointPolicy(t::T) where T<:Tuple = new{T}(t)
end

function MarkovGames.behavior(p::JointPolicy, s)
    return map(p.pols) do pol
        behavior(pol, s)
    end |> ProductDistribution
end

function MarkovGames.behavior_info(pol::MCTSPlanner, s)
    a, a_info = action_info(pol, s)
    return Deterministic(a), a_info
end

MarkovGames.behavior(pol::MCTSPlanner, s) = first(behavior_info(pol, s))


##

struct SinglePlayerAlphaZeroPolicy{P<:AlphaZeroPlanner} <: Policy
    policy::P
    player::Int
end

MarkovGames.behavior(pol::SinglePlayerAlphaZeroPolicy, s) = behavior(pol.policy, s)[pol.player]

function JointPolicy(
        game::MG, 
        mcts_solver::MCTSSolver, 
        az_policy::AlphaZeroPlanner;
        mcts_player::Int = 1,
        mcts_az_params  = (;max_iter=0) # mcts by default just exploiting policy network (no search) 
    )
    az_player = MarkovGames.other_player(mcts_player)
    az_policy_to_exploit = AlphaZeroPlanner(az_policy; mcts_az_params...)
    mdp = ExploitabilityMDP(game, az_policy_to_exploit, mcts_player)
    mcts_policy = solve(mcts_solver, mdp)
    single_az_policy = SinglePlayerAlphaZeroPolicy(az_policy, az_player)
    return if isone(mcts_player)
        JointPolicy(mcts_policy, single_az_policy)
    else
        JointPolicy(single_az_policy, mcts_policy)
    end
end

function ExploitabilitySim(
        sim::RolloutSimulator, 
        game::MG, 
        mcts_solver, 
        az_policy::AlphaZeroPlanner; 
        mcts_player     = 1, 
        mcts_az_params  = (;max_iter=0), # mcts by default just exploiting policy network (no search)
        s0              = rand(initialstate(game))
    )
    joint_policy = JointPolicy(game, mcts_solver, az_policy; mcts_player, mcts_az_params)
    return ExploitabilitySim(sim, game, joint_policy; s0)
end

function ExploitabilitySim(sim::RolloutSimulator, game::MG, pol::JointPolicy; s0)
    return Sim(game, pol, s0; simulator=sim)
end

function ExploitabilitySim(
        sims::AbstractVector{<:RolloutSimulator}, 
        game::MG, 
        mcts_solver::MCTSSolver, 
        az_policy::AlphaZeroPlanner; 
        mcts_player         = 1, 
        mcts_az_params      = (;max_iter=0), # mcts by default just exploiting policy network (no search)
        s0::AbstractVector  = [rand(sims[i].rng, initialstate(game)) for i in eachindex(sims)]
    )
    joint_policy = JointPolicy(game, mcts_solver, az_policy; mcts_player, mcts_az_params)
    return map(sims, s0) do sim, s
        Sim(
            game, joint_policy, s;
            simulator = sim
        )
    end
end

dist2states(rng::AbstractRNG, game::MG{S}, s0::S, n::Int) where S = repeat(s0, n)
dist2states(rng::AbstractRNG, game::MG{S}, s0, n::Int) where S = [rand(rng, s0) for _ in 1:n]

function evaluate(
        game::MG, 
        mcts_solver::MCTSSolver, 
        az_policy::AlphaZeroPlanner;
        mcts_az_params      = (;max_iter=0), 
        max_steps           = 30,
        n                   = 100,
        s0                  = initialstate(game),
        mcts_player::Int    = 0,
        parallel::Bool      = true
    )
    if iszero(mcts_player) # run mcts for both players
        sims1 = ExploitabilitySim(
            [RolloutSimulator(;max_steps, rng=Random.default_rng()) for _ in 1:n],
            game,
            mcts_solver,
            az_policy;
            mcts_az_params,
            s0 = dist2states(Random.default_rng(), game, s0, n),
            mcts_player = 1
        )
        res1 = parallel ? run_parallel(sims1) : run(sims1)
        sims2 = ExploitabilitySim(
            [RolloutSimulator(;max_steps, rng=Random.default_rng()) for _ in 1:n],
            game,
            mcts_solver,
            az_policy;
            mcts_az_params,
            s0 = dist2states(Random.default_rng(), game, s0, n),
            mcts_player = 2
        )
        res2 = parallel ? run_parallel(sims2) : run(sims2)
        return (
            convert(Vector{Float64}, res1.reward), 
            convert(Vector{Float64}, res2.reward)
        )
    else
        sims = ExploitabilitySim(
            [RolloutSimulator(;max_steps, rng=Random.default_rng()) for _ in 1:n],
            mcts_solver,
            az_policy;
            mcts_az_params,
            s0 = dist2states(Random.default_rng(), game, s0, n),
            mcts_player
        )
        res = parallel ? run_parallel(sims) : run(sims)
        return convert(Vector{Float64}, res.reward)
    end
end

"""

`res[player_idx][model_idx, sim_idx]`

"""
function exploitability(
        game::MG, 
        basedir::String; 
        oracle                      = AZ.load_oracle(basedir), 
        planner::AlphaZeroPlanner   = AlphaZeroPlanner(game, oracle),
        mcts_solver::MCTSSolver     = MCTSSolver(n_iterations=10),
        verbose                     = true,
        kwargs...
    )
    modeldir = joinpath(basedir, "models")
    res = map(readdir(modeldir, join=true)) do model_path
        verbose && println(last(splitpath(model_path)))
        Flux.loadmodel!(planner, model_path)
        evaluate(game, mcts_solver, planner; kwargs...)
    end
    return map((1,2)) do player
        mapreduce(hcat, res) do res_i
            res_i[player]
        end |> permutedims
    end
end

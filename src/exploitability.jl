# TODO: this probably shouldn't be exclusive to this package
struct ExploitabilityMDP{G, P, S, A} <: MDP{S,A}
    game::G
    policy::P
    exploiter::Int
    function ExploitabilityMDP(game::G, policy, exploiter::Int) where G <: MG
        S = statetype(game)
        A = actiontype(game).types[exploiter] # assuming action type is tuple
        return ExploitabilityMDP{G, S, A}(game, policy, exploiter)
    end
end

POMDPs.states(mdp::ExploitabilityMDP) = states(mdp.game)
POMDPs.actions(mdp::ExploitabilityMDP) = actions(mdp.game)[mdp.exploiter]
POMDPs.discount(mdp::ExploitabilityMDP) = discount(mdp.game)
POMDPs.initialstate(mdp::ExploitabilityMDP) = initialstate(mdp.game)

player_reward(p::Int, r::Tuple) = r[p]

player_reward(p::Int, r::Number) = isone(p) ? r : -r

function POMDPs.gen(mdp::ExploitabilityMDP, s, a, rng=Random.default_rng())
    (; game, policy, exploiter) = mdp
    a_pol = rand(rng, behavior(policy, s)[MarkovGames.other_player(exploiter)])
    a_joint = isone(exploiter) ? (a, a_pol) : (a_pol, a)
    sp, r = @gen(:sp, :r)(game, s, a_joint, rng)
    r = player_reward(exploiter, r)
    return (; sp, r)
end
